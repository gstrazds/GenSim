You are an AI in robot simulation code. I will provide you one or more example task descriptions with corresponding code implementations. Please first describe the task in natural languages and then write the implementation code for controlling a robot to perform the specified task. 

Now I will provide you some reference code and then you can write the robot control code for the task:
TASK_SPEC_TEMPLATE

Examples of implementations for similar tasks:

for {'task-name': "packing-shapes", 'task-description': "pick up blue blocks and place them into red bowls"}
"""
import numpy as np
from typing import Dict, List, Any
from gensim.robocodegen import RobotScript, EnvironmentExt, PickAndPlaceAction


class PlaceBlueBlocksInRedBowls(RobotScript):
    """pick up blue blocks and place them into red bowls."""

    def __init__(self, env: EnvironmentExt, task_spec):
        super().__init__(env, task_name: task_spec['task-name'], instructions: task_spec['task-description'])
        self.env_reset(env)

    def env_reset(self, env):
        super().env_reset(env)
        # a list of blocks that are blue
        self.blue_blocks = list(filter(lambda oid: env.is_object_type(oid, 'block') and env.is_object_color(oid, 'blue'), self.scene_objects))

        # a list of bowls that are red
        self.red_bowls = list(filter(lambda oid: env.is_object_type(oid, 'bowl') and env.is_object_color(oid, 'red'), self.scene_objects))
        self.current_target_index = -1

    def get_target_id(self):
        if not self.red_bowls:  # if there are no target bowls available
            self.current_target_index = -1
        else:
            # cycle through the available target bowls
            self.current_target_index += 1
            if self.current_target_index >= len(self.red_bowls):
                self.current_target_index = 0
        if self.current_target_index >= 0:
            return self.red_bowls[self.current_target_index]
        return None

    def act(self, obs, info):
        ''' Each time this method is invoked, move one blue block into a red bowl.
        In order to distribute the blocks as evenly as possible, we cycle through the available bowls.
        '''

        if not self.blue_blocks:  # if there are no more blue blocks available, there's nothing to do.
            return None
        block_id = self.blue_blocks.pop()  # select one blue block, removing it from the list of items that need to be moved
        bowl_id = self.get_target_id() # choose a destination
        if bowl_id is None:
            return None
        pick_pose = self.env.get_pick_pose(block_id)
        place_pose = self.env.get_place_pose(block_id, bowl_id)  # a pose that's appropriate for placing the first object onto or in the target object

        return PickAndPlaceAction(pick_pose, place_pose, block_id)  # arguments for performing a pick and place action in the environment

"""


You should implement the task as a subclass of RobotScript, with a method with signature 'act(self, obs: str, info: Dict[str, Any])'. Do not use libraries, functions, and assets that you don't know. You can use methods from numpy or pybullet, if needed. You do not need other extra helper functions. Comment the code liberally to explain what each piece does and why it's written that way.

Now write the code for the task "TASK_NAME_TEMPLATE" in a python code block starting with ```python.  Reminder: TASK_STRING_TEMPLATE
